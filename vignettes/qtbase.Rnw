% \VignetteIndexEntry{Introduction to qtbase}
% \VignetteKeywords{foreign interface, GUI}
% \VignettePackage{qtbase}
\documentclass[10pt]{article}

\usepackage{times}
\usepackage{hyperref}

\textwidth=6.5in
\textheight=8.5in
% \parskip=.3cm
\oddsidemargin=-.1in
\evensidemargin=-.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textbf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Qt}{\software{Qt}}
\newcommand{\qtbase}{\Rpackage{qtbase}}

\title{An Introduction to \qtbase{}}
\author{Michael Lawrence}
\date{\today}

\begin{document}

\maketitle

<<setup,echo=FALSE>>=
options(width=72)
library(qtbase)
supported <- 
!length(grep("darwin", R.version$platform)) || 
nzchar(Sys.getenv("SECURITYSESSIONID"))
@

\section{Overview}

The \qtbase{} package aims to interface all of \Qt\/ with \R. \Qt\/ is
an application framework, best known for its collection of GUI
widgets, and is developed by Nokia. Please see
\url{http://qt.nokia.com} for more information. 

All methods in \Qt\/ may be invoked from \R, and \R\/ may extend any \Qt\/
class. Here is a basic example of \qtbase{} syntax: 
<<syntax,eval=FALSE>>=
button <- Qt$QPushButton("Press Me!")
qconnect(button, "pressed", function() print("Pressed"))
button$show()
@ 
<<syntax-real,echo=FALSE>>=
if (supported) {
<<syntax>>
}
@ 
% 
In the above, we create a button, register a callback
that is called when the button is pressed, and show the button on
the screen.

In the above example, we manipulate objects from all three types in
the core \qtbase{} API: libraries (\Rclass{RQtLibrary}), classes
(\Rclass{RQtClass}), and instances (\Rclass{RQtObject}).  These have
an approximately hierarchical relationship, and we will discuss each
in the following sections.

\section{Libraries}
\label{sec:libraries}

Each package that binds a library provides a \Rclass{RQtLibrary}
object. The \qtbase{} package itself provides the \Rcode{Qt} object,
which binds the Qt library.
<<Qt,eval=FALSE>>=
Qt
@
<<Qt-real,echo=FALSE>>=
if (supported) {
<<Qt>>
}
@ 
% 
As evident from the above output, each library object is a container
of class objects, of type \Rclass{RQtClass}. 

A \Rclass{RQtLibrary} is a special type of \Rcode{environment} and may be
manipulated as any other environment:
<<libraries-as-environments,eval=FALSE>>=
head(ls(Qt))
Qt$QPushButton
@
<<libraries-as-environments-real,echo=FALSE>>=
if (supported) {
<<libraries-as-environments>>
}
@ 
% 
We have just extracted the \R\/ class object for the C++ \Rcode{QWidget}
class, and we describe such objects in the next section.

\section{Classes}
\label{sec:classes}

A class object might represent an actual C++ class, an \R\/ derivative of
a C++ class, or a C++ namespace. A class object is a special type of \R\/
\Rcode{function} that serves as the constructor for the class:
<<QWidget,eval=FALSE>>=
button <- Qt$QPushButton("Press Me!")
@
<<QWidget-real,echo=FALSE>>=
if (supported) {
<<QWidget>>
}
@ 
% 
Beyond its role as a constructor, the class object is a container of
static methods (or simple functions in the case of a namespace) and
enumerations. We invoke the static method \Rcode{tr} for translating text:
<<tr,eval=FALSE>>=
Qt$QPushButton$tr("Hello World")
@
<<tr-real,echo=FALSE>>=
if (supported) {
<<tr>>
}
@ 
% 
The above code relies on a method for \Rcode{\$} that is specially
defined for the \Rclass{RQtClass}.

\section{Objects}
\label{sec:objects}

The \Rcode{button} object constructed above is a
\Rclass{RQtObject}. Like \Rclass{RQtClass}, \Rclass{RQtObject} is an
\Rcode{environment}. It contains methods and, for \Rcode{QObject}
derived instances, properties.
<<show,eval=FALSE>>=
button$show()
@
<<show-real,echo=FALSE>>=
if (supported) {
<<show>>
}
@ 

% 
In the above, we obtain the \Rcode{show} method and invoke it to show
the button on the screen.

As \Rcode{QPushButton} extends \Rcode{QObject}, it has properties, and
one of its properties is its \Rcode{text} label:
<<text,eval=FALSE>>=
button$text
button$text <- "PUSH ME!"
@
<<text-real,echo=FALSE>>=
if (supported) {
<<text>>
}
@ 

\section{Connecting Signal Handlers}
\label{sec:signals}

In any GUI, the application needs to react to user
events. Qt supports this with signals. Here, we connect an \R\/ handler
to a signal that is emitted when the button is \Rcode{pressed}:
<<qconnect,eval=FALSE>>=
qconnect(button, "pressed", function() print("pushed"))
@
<<qconnect-real,echo=FALSE>>=
if (supported) {
<<qconnect>>
}
@ 

% 
The signal connection is achieved with the \Rcode{qconnect}
function. The \R\/ function is invoked when the \Rcode{pressed} signal
is emitted on \Rcode{button}.

We now have a trivial but complete GUI. A widget, specifically a
button, is displayed on the screen, and \R\/ code is responding to user
input, a click of the button. For more examples, please see
\Rcode{demo(package="qtbase")}.  The rest of this vignette treats
advanced concepts, including the ability to extend C++ classes in \R.

\section{Extending C++ Classes}
\label{sec:extension}

Many C++ libraries expect the user to extend C++ classes in normal
course. For interfacing \R\/ with \Qt, this presents a complication: the \R\/
user must be able to extend a \Qt/C++ class. 

We will demonstrate this functionality by example. Our aim is to
extend the \Rcode{QValidator} class to restrict the input in a text
entry (\Rcode{QTextEdit}) to positive numbers. The first step is to
declare the class, and then methods are added individually to the
class definition, in an analogous manner to the \Rpackage{methods}
package. We start by declaring the class:
<<qsetClass,eval=FALSE>>=
qsetClass("PositiveValidator", Qt$QValidator)
@
<<qsetClass-real,echo=FALSE>>=
if (supported) {
<<qsetClass>>
}
@ 
% 
The class name is given as \Rcode{PositiveValidator} and it extends the
\Rcode{QValidator} class in \Qt. Note that only single inheritance is
supported.

As a side-effect of the call to \Rfunction{qsetClass}, a variable
named \Rcode{PositiveValidator} has been assigned into the global
environment (the scoping is similar to \Rfunction{methods::setClass}):
<<list-validator-class,eval=FALSE>>=
PositiveValidator
@
<<list-validator-class-real,echo=FALSE>>=
if (supported) {
<<list-validator-class>>
}
@ 

% 
To define a method on our class, we call the \Rfunction{qsetMethod}
function:
<<validate,eval=FALSE>>=
validatePositive <- function(input, pos) {
  val <- suppressWarnings(as.integer(input))
  if (!is.na(val)) {
    if (val > 0)
    Qt$QValidator$Acceptable
    else Qt$QValidator$Invalid
  } else {
    if (input == "")
    Qt$QValidator$Acceptable
    else Qt$QValidator$Invalid
  }
}
@
<<validate-real,echo=FALSE>>=
if (supported) {
<<validate>>
}
@ 
<<qsetMethod,eval=FALSE>>=
qsetMethod("validate", PositiveValidator, validatePositive)
@ 
<<qsetMethod-real,echo=FALSE>>=
if (supported) {
<<qsetMethod>>
}
@ 
% 
The virtual method \Rcode{validate} declared by \Rcode{QValidator} has
been overriden by the \Rcode{PositiveValidator} class.  The
\Rfunction{validatePositive} function implements the override and has
been defined invisibly for readability.

As an \Rclass{RQtClass} object, we can create an instance by invoking
\Rfunction{PositiveValidator} as a \Rcode{function}:
<<construct-validator,eval=FALSE>>=
validator <- PositiveValidator()
@ 
<<construct-validator-real,echo=FALSE>>=
if (supported) {
<<construct-validator>>
}
@ 

% 
Now that we have our validator, we can use it with a text entry:
<<text-entry,eval=FALSE>>=
e <- Qt$QLineEdit()
v <- PositiveValidator(e)
e$setValidator(v)
e$show()
@ 
<<text-entry-real,echo=FALSE>>=
if (supported) {
<<text-entry>>
}
@ 

Often, it is necessary to customize the constructor of an \R\/
class. The \R\/ function implementing the constructor must be passed
during the call to \Rfunction{qsetClass}. Here, we extend
\Rcode{QMessageBox} to create a dialog, shown when the application is
closing, that asks the user whether a document should be saved:
<<extend-window-title,eval=FALSE>>=
qsetClass("SaveConfirmationDialog", Qt$QMessageBox, 
function(filename = NULL, parent = NULL) 
{
  super(icon = Qt$QMessageBox$Question, title = "Save confirmation", 
  text = "Save the current document?", 
  buttons = Qt$QMessageBox$Cancel | Qt$QMessageBox$Discard | 
  Qt$QMessageBox$Save,
  parent = parent)
  this$filename <- filename
})
@ 
<<extend-window-title-real,echo=FALSE>>=
if (supported) {
<<extend-window-title>>
}
@ 

% 
The \Rfunction{super} function exists only within the scope of the
constructor. It passes its arguments to the constructor of the super
(parent) class. Above, we pass various parameters of the dialog
to the \Rclass{QMessageBox} constructor.  By convention, every
\Rclass{QObject} derivative, including any widget, accepts its parent
instance as an argument to its constructor and forwards it to the
super constructor. Another special variable, \Robject{this},
corresponds to the current instance being constructed. We reference it
to create an attribute for the \Robject{filename} on the
instance. Similar to attributes on ordinary R objects, these
attributes are dynamically typed and are implicitly defined at the
instance-level by setting a value.

Within a method implementation, \Rcode{super} will call a
named method in the parent class. We demonstrate in our override of
\Rfunction{accept}, which is invoked when the user decides to save the
document:
<<accept-override,eval=FALSE>>=
qsetMethod("accept", SaveConfirmationDialog, function() {
  saveDocument(filename)
  super("accept")
})
@ 
<<accept-override-real,echo=FALSE>>=
if (supported) {
<<accept-override>>
}
@ 

% 
After saving the current document, the method calls \Rfunction{super}
to forward the user response to one of the super classes. This is
similar to \Rfunction{callNextMethod}, except \Rfunction{super} will
invoke any named method, not only the current one. Also,
\Rfunction{super} does not implicitly forward method arguments: they
must be passed after the name argument.

For more examples of extending C++ classes, please see
\Rcode{demo(package="qtbase")}.

\end{document}
